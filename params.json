{"name":"MicroFlow","tagline":"Lightweight workflow engine","body":"Getting Started\r\n=======================\r\n\r\n* [What is MicroFlow?](#what-is-microflow)\r\n* [NuGet Package](#nuget-package)\r\n* [Activities](#activities)\r\n* [Nodes](#nodes)\r\n* [Data flow](#data-flow)\r\n* [Flow creation](#flow-creation)\r\n* [Fault handling](#fault-handling)\r\n* [Graph generator](#graph-generator)\r\n* [Sample](#sample)\r\n* [License](https://raw.githubusercontent.com/akarpov89/MicroFlow/master/License.txt)\r\n\r\nWhat is MicroFlow?\r\n---------------------\r\n\r\nMicroFlow is a lightweight workflow engine. It allows to build workflows as flowcharts.\r\nEvery flow is constructed from a limited number of connected nodes.\r\n\r\nFeatures:\r\n* Code-centric, no XAML\r\n* Data flow friendly: easy to pass data from one activity to another\r\n* Integrated dependency injection\r\n* Flow validation\r\n* Visualization support\r\n\r\nAvailable node types:\r\n* **activity** node represents user-defined action;\r\n* **condition** node represents decision (like `if-else` statement);\r\n* **switch** node represents multiway branch (like `switch` statement);\r\n* **fork-join** node represents concurrent activities;\r\n* **block** node groups several nodes (like blocks in programming languages). \r\n\r\nNuGet Package\r\n---------------\r\n\r\nMicroFlow is available on [NuGet](https://www.nuget.org/packages/MicroFlow/) and [MyGet](https://www.myget.org/gallery/microflow/).\r\n\r\nTarget frameworks:\r\n* .NET 4.0+\r\n* .NET Core\r\n* Portable Libraries (net45+win8+wpa81+wp8)\r\n\r\nActivities\r\n-------------\r\n\r\nThe user-defined activities should inherit from one of the following base classes\r\n\r\n##### Activity&lt;TResult&gt;\r\nThe most generic activity returning the result of type `TResult`.\r\nAn implementation must override the method\r\n\r\n```cs\r\npublic abstract Task<Result> Execute();\r\n```\r\n\r\n##### Activity\r\nThe most generic activity without returning value. An implementation must override the method\r\n\r\n```cs\r\nprotected abstract Task ExecuteCore();\r\n``` \r\n\r\n##### SyncActivity&lt;TResult&gt;\r\nThe base class of the synchronous activities returning the value of type `TResult`.\r\nAn implemenation must override the method:\r\n\r\n```cs\r\nprotected abstract TResult ExecuteActivity();\r\n```\r\n\r\n##### SyncActivity\r\nThe base class of the synchronous activities without returning value.\r\nAn implemenation must override the method:\r\n\r\n```cs\r\nprotected abstract void ExecuteActivity();\r\n```\r\n\r\n##### BackgroundActivity&lt;TResult&gt;\r\nProvides the way to execute a function as a separate background task.\r\nAn implemenation must override the method:\r\n\r\n```cs\r\nprotected abstract TResult ExecuteCore();\r\n```\r\n\r\n`BackgroundActivity<TResult>` exposes the following properties:\r\n* `CancellationToken` - allows the work to be cancelled;\r\n* `Scheduler` - schedules the worker task;\r\n* `IsLongRunning` - allows to hint `TaskScheduler` that task will be a long-running operation.  \r\n\r\n##### BackgroundActivity\r\nProvides the way to execute a function as a separate background task. \r\nAn implemenation must override the method:\r\n\r\n```cs\r\nprotected abstract void ExecuteCore();\r\n```\r\n\r\n`BackgroundActivity` exposes the same properties as `BackgroundActivity<TResult>`.\r\n\r\n##### IFaultHandlerActivity\r\nThe interface of all fault handlers. Every fault handler must provide the following property:\r\n\r\n```cs\r\nException Exception { get; set; }\r\n```\r\n\r\nNodes\r\n----------\r\n\r\nThe `FlowBuilder` class provides the way to create nodes of the flow.\r\n\r\n##### ActivityNode&lt;TActivity&gt;\r\n\r\n```cs\r\nvar node = builder.Activity<SomeActivity>(\"Node name\");\r\n\r\nnode.ConnectTo(anotherNode)\r\n    .ConnectFaultTo(faultHandler)\r\n    .ConnnectCancellationTo(cancellationHandler);\r\n```\r\n\r\n##### ConditionNode\r\n\r\n```cs\r\nvar node = builder.Condition(\"Node name\");\r\nnode.WithCondition(() => boolExpr);\r\n\r\nnode.ConnectFalseTo(falseBranchNode)\r\n    .ConnectTrueTo(trueBranchNode);\r\n```\r\n\r\nThere is also an alternative syntax that allows to create `if-then-else` constructs:\r\n\r\n```cs\r\nvar node = builder\r\n    .If(\"Condition1\", () => boolExpr1).Then(node1)\r\n    .ElseIf(\"Condition2\", () => boolExpr2).Then(node2)\r\n    .Else(node3);    \r\n```\r\n\r\nNotice that in this case `node` is initial `ConditionNode` (the one with condition description \"Condition description\").\r\n\r\n##### SwitchNode\r\n\r\n```cs\r\nvar node = builder.SwitchOf<int>(\"Node name\");\r\nnode.WithChoice(() => someIntExpression);\r\n\r\nnode.ConnectCase(0).To(caseHandler1)\r\n    .ConnectCase(1).To(caseHandler2)\r\n    .ConnectCase(42).To(caseHandler3)\r\n    .ConnectDefault(caseHandler4).\r\n```\r\n\r\n##### ForkJoinNode\r\n\r\n```cs\r\nvar node = builder.ForkJoin(\"Node name\");\r\n\r\nvar fork1 = node.Fork<SomeForkActivity>(\"Fork 1 name\");\r\nvar fork2 = node.Fork<SomeAnotherForkActivity>(\"Fork 2 name\");\r\nvar fork3 = node.Fork<SomeActivity>(\"Fork 3 name\");\r\n```\r\n\r\n##### BlockNode\r\n\r\n```cs\r\nvar node = builder.Block(\"Optional node name\", (block, blockBuilder) =>\r\n{\r\n    var activity1 = blockBuilder.Activity<SomeActivity>();\r\n    var activity2 = blockBuilder.Activity<SomeAnotherActivity>();\r\n    \r\n    activity1.ConnectTo(activity2);\r\n});\r\n```\r\n\r\n##### Default fault handler\r\n\r\nEvery activity node should be connected with some specific or default fault handler\r\n\r\n```cs\r\nbuilder.WithDefaultFaultHandler<MyFaultHandler>(); \r\n```\r\n\r\n##### Default cancellation handler\r\n\r\nEvery activity node should be connected with some specific or default cancellation handler\r\n\r\n```cs\r\nbuilder.WithDefaultCancellationHandler<MyCancellationHandler>();\r\n```\r\n\r\nData flow\r\n--------------\r\n\r\nAs flow executes data transfers from one activity to another.\r\nThe MicroFlow has two mechanisms to define the data flow: _bindings_ and _variables_.\r\n\r\nIn the examples below we will use the following activities:\r\n\r\n```cs\r\npublic class ReadIntActivity : SyncActivity<int>\r\n{\r\n    protected override int ExecuteActivity()\r\n    {\r\n        return int.Parse(Console.ReadLine());\r\n    }\r\n}\r\n\r\npublic class SumActivity : SyncActivity<int>\r\n{\r\n    [Required] public int FirstNumber { get; set; }\r\n    [Required] public int SecondNumber { get; set; }\r\n    \r\n    protected override int ExecuteActivity()\r\n    {\r\n        return FirstNumber + SecondNumber;\r\n    }\r\n}\r\n``` \r\n\r\n##### Binding to activity result\r\n\r\nIn this example we bind properties `FirstNumber` and `SecondNumber` to the results\r\nof `readFirstNumber` and `readSecondNumber`:\r\n\r\n```cs\r\nvar readFirstNumber = builder.Activity<ReadIntActivity>();\r\nvar readSecondNumber = builder.Activity<ReadIntActivity>();\r\n\r\nvar sumTwoNumbers = builder.Activity<SumActivity>();\r\n\r\nsumTwoNumbers.Bind(a => a.FirstNumber).ToResultOf(readFirstNumber);\r\nsumTwoNumbers.Bind(a => a.SecondNumber).ToResultOf(readSecondNumber);\r\n```\r\n\r\n##### Binding to value\r\n\r\nIn this example we bind `FirstNumber` to the value `42` and `SecondNumber` to `5`:\r\n\r\n```cs\r\nvar sumTwoNumbers = builder.Activity<SumActivity>();\r\n\r\nsumTwoNumbers.Bind(a => a.FirstNumber).To(42);\r\nsumTwoNumbers.Bind(a => a.SecondNumber).To(5);\r\n```\r\n\r\n##### Binding to expression\r\n\r\nIn this example we bind `FirstNumber` to expression using the result of the `readFirstNumber`\r\nand `SecondNumber` to function call `Factorial(5)` expression:\r\n\r\n```cs\r\nvar readFirstNumber = builder.Activity<ReadIntActivity>();\r\n\r\nvar firstNumber = Result<int>.Of(readFirstNumber); // Create result thunk\r\n\r\nvar sumTwoNumbers = builder.Activity<SumActivity>();\r\n\r\nsumTwoNumbers.Bind(a => a.FirstNumber).To(() => firstNumber.Get() + 1);\r\nsumTwoNumbers.Bind(a => a.SecondNumber).To(() => Factorial(5)); \r\n```\r\n\r\n##### Using flow variables\r\n\r\nThe MicroFlow allows to create and use variables scoped to the whole flow or to some specific block:\r\n\r\n```cs\r\nvar globalVariable = builder.Variable<int>();\r\n\r\nvar block = builder.Block(\"my block\", (thisBlock, blockBuilder) =>\r\n{\r\n    var localVariable = thisBlock.Variable<string>(\"initial value\");\r\n});\r\n```\r\n\r\nIt's possible to change the variable value after completion of some activity:\r\n\r\n_Assign activity result_:\r\n\r\n```cs\r\n var myVar = builder.Variable<int>();\r\n \r\n var readFirstNumber = builder.Activity<ReadIntActivity>();\r\n\r\n myVar.BindToResultOf(readFirstNumber);\r\n```\r\n\r\n_Assign some constant value_:\r\n\r\n```cs\r\nvar myVar = builder.Variable<bool>();\r\n \r\nvar readFirstNumber = builder.Activity<ReadIntActivity>();\r\n\r\nreadFirstNumber.OnCompletionAssign(myVar, true);\r\n```\r\n\r\n_Update value without using activity result_:\r\n\r\n```cs\r\nvar myVar = builder.Variable<int>(42);\r\n \r\nvar readFirstNumber = builder.Activity<ReadIntActivity>();\r\n \r\nreadFirstNumber.OnCompletionUpdate(\r\n    myVar, \r\n    oldValue => oldValue + 1\r\n);\r\n```\r\n\r\n_Update value using activity result_:\r\n\r\n```cs\r\nvar myVar = builder.Variable<int>(42);\r\n \r\nvar readFirstNumber = builder.Activity<ReadIntActivity>();\r\n \r\nreadFirstNumber.OnCompletionUpdate(\r\n    myVar, \r\n    (int oldValue, int result) => oldValue + result\r\n);\r\n```\r\n\r\nLater the current value of a variable can retrieved via property `CurrentValue`:\r\n\r\n```cs\r\nvar myVar = builder.Variable<int>();\r\n...\r\nvar sumTwoNumbers = builder.Activity<SumActivity>();\r\n\r\nsumTwoNumbers.Bind(a => a.FirstNumber)\r\n             .To(() => myVar.CurrentValue);\r\n...\r\n```\r\n\r\nFlow creation\r\n-----------------\r\n\r\nEvery flow is a subclass of the `Flow` abstract class. \r\nThe `Flow` base class provides the way to validate and run the\r\nthe constructed flow:\r\n\r\n```cs\r\npublic ValidationResult Validate();\r\npublic Task Run();\r\n```\r\n\r\nIn order to create new flow definition it's required to describe the flow structure \r\nand give the flow a name:\r\n\r\n```cs\r\npublic class MyFlow : Flow\r\n{\r\n    public override string Name => \"My brand new flow\";\r\n    \r\n    protected override void Build(FlowBuilder builder)\r\n    {\r\n        // Create and connect nodes\r\n    }\r\n}\r\n```\r\n\r\nThe `Flow` —Ålass also has several configuration extension points:\r\n* `ConfigureServices` method allows to register services required for activities (dependency injection mechanism);\r\n* `ConfigureValidation` method allows to add custom flow validators;\r\n* `CreateFlowExecutionLogger` method allows to setup execution logging.\r\n\r\n##### Services registration\r\n\r\nConfiguring services is possible via overriding the method `ConfigureServices`\r\n\r\n```cs\r\nprotected virtual void ConfigureServices(\r\n    [NotNull]IServiceCollection services\r\n);\r\n```\r\n\r\nLet's say our `ReadIntActivity` uses `IReader` service:\r\n\r\n```cs\r\npublic interface IReader\r\n{\r\n    string Read();\r\n}\r\n\r\npublic class ReadIntActivity : SyncActivity<int>\r\n{\r\n    private readonly IReader _reader;\r\n    \r\n    public ReadIntActivity(IReader reader)\r\n    {\r\n        _reader = reader;\r\n    }\r\n    \r\n    protected override int ExecuteActivity() => int.Parse(_reader.Read());\r\n}\r\n```\r\n\r\n`ConfigureServices` method allows to register service implementation\r\npassing to the `ReadIntActivity` constructor whenever the activity is created.\r\n\r\n`IServiceCollection` has several helper methods:\r\n* `AddSingleton<TService>(object instance)` registers the specified instance as a service implementation.\r\n* `AddDisposableSingleton<TService>(IDisposable instance)` registers the specified instance as a service implementation;\r\nAfter finishing the flow execution the instance will be disposed.\r\n* `AddSingleton<TService, TImplementation>()` registers the type of the service implementation. \r\nThe single instance of the `TImplementation` will be used throughout the whole flow;\r\n* `AddTransient<TService, TImplementation>()` registers the type of the service implemenation.\r\nThe new instance of the `TImplementation` will be created each time it's needed to pass the\r\nservice to the activity constructor.\r\n\r\n> **Note:** Current implementation allows to register only service implementation types having a default constructor.\r\n\r\n##### Logging\r\n\r\nWhile no logging is performed by default it's possible to specify the flow execution logger \r\nby overriding the method:\r\n\r\n```cs\r\nprotected virtual ILogger CreateFlowExecutionLogger();\r\n```\r\n\r\nThe `ILogger` interface declares the verbosity level property and several overloads to \r\nlog messages and exceptions.\r\n\r\nThe MicroFlow provides two simple implementations:\r\n* `NullLogger` does nothing;\r\n* `ConsoleLogger` prints messages to the console.\r\n\r\n##### Validation\r\n\r\nMicroFlow supports flow validation. Currently by default the following checks are performed:\r\n* Initial node availability;\r\n* Loops absence (node shouldn't point to itself);\r\n* Condition expression presense in condition nodes;\r\n* Choice expression presence in switch nodes;\r\n* Nodes reachability;\r\n* Fault and cancellation handlers availability for activities;\r\n* Selfcontainedness of blocks;\r\n* Acyclicity of blocks;\r\n* Required bindings availablity;\r\n* Activity default constructor availability.\r\n\r\nAny `Flow` implementation can add custom validators by overriding the `ConfigureValidation` method:\r\n\r\n```cs\r\nprotected virtual void ConfigureValidation(\r\n    [NotNull] IValidatorCollection validators\r\n)\r\n```\r\n\r\nAll validators inherit from the `FlowValidator` abstract class.\r\n`FlowValidator` provides the implementation of visiting every node in the flow and then\r\nperforming global validation. Global validation assumes that during the visiting phase validator accumulates \r\nsome information that should be checked later - on the global validation phase. \r\n`FlowValidator` implementation must override `VisitXxx` methods for each kind of node.\r\nGlobal validation is fully optional and can be implemented by overriding the `PerformGlobalValidation` method.\r\n\r\nFuture plans:\r\n* Binding expressions validation;\r\n* Variables scope validation;\r\n* Forks data usage validaton\r\netc.\r\n\r\nFault handling\r\n----------------------\r\n\r\nAs it was mentioned earlier if activity ends up with an exception\r\nthen fault handler activity takes control.\r\nBut there are cases when an exception occures before activity execution. For instance:\r\n\r\n* Exception in activity constructor;\r\n* Exception in service constructor;\r\n* Exception during condition expression evaluation;\r\n\r\nand so on.\r\n\r\nSuch situations differ from cases when activity results faulted `Task` and therefore\r\nrequire special handling.\r\n\r\nThe `Flow.Run()` method returns a `Task`. \r\nIf the flow completes normally then returned `Task` ends up with the `RanToCompletion` status.\r\nBut when an unexpected exception is encountered `Task` completes as `Faulted`.\r\n\r\nThus to avoid unobserved exceptions one should attach a continuation to the `Task` returned from\r\nthe `Run` method:\r\n\r\n```cs\r\nvar flow = new MyFlow();\r\n\r\nvar flowTask = flow.Run();\r\n\r\nflowTask.ContinueWith(t =>\r\n{\r\n    if (t.IsFaulted)\r\n    {\r\n        // Handle exception\r\n    }\r\n    else if (t.Status == TaskStatus.RanToCompletion)\r\n    {\r\n        // Flow is completed normally\r\n    }\r\n});\r\n```\r\n\r\nGraph generator\r\n--------------------\r\n\r\nThe MicroFlow comes with the tool called _MicroFlow.Graph_ that allows to generate *.dgml files.\r\nDGML is an XML-based file format for directed graphs supported by the Microsoft Visual Studio 2010 and later.\r\n\r\nMicroFlow.Graph.exe is a console program with two required arguments:\r\n* path to or name of the assembly containing the flow definition class;\r\n* flow class name.\r\n\r\nExample: `MicroFlow.Graph MicroFlow.Test.dll Flow1`\r\n\r\nThe generated sample flow is presented below.\r\n\r\n> **Note:** Graph generation is available only if the flow has a default constructor\r\n\r\nSample\r\n-------------\r\n\r\nLet's create the simple flow: \r\nread two numbers and if first number greater than a second output \"first > second\" \r\notherwise output \"first <= second\". The graphical scheme of the flow is presented below. \r\n![ExampleFlow1](https://raw.github.com/akarpov89/MicroFlow/master/content/flow1.png)\r\n\r\nAt first let's create activity for reading numbers. It will use the following `IReader` interface.\r\n\r\n```cs\r\npublic interface IReader\r\n{\r\n    string Read();\r\n}\r\n```\r\n\r\nBecause reading activity is synchronous and returns an integer \r\nit will inherit from the `SyncActivity<int>` class.\r\n\r\n```cs\r\npublic class ReadIntActivity : SyncActivity<int>\r\n{\r\n    private readonly IReader _reader;\r\n\r\n    public ReadIntActivity(IReader reader)\r\n    {\r\n        _reader = reader;\r\n    }\r\n\r\n    protected override int ExecuteActivity() => int.Parse(_reader.Read());\r\n}\r\n```\r\n\r\nNow let's create output activity. It will use the following `IWriter` interface:\r\n\r\n```cs\r\npublic interface IWriter\r\n{\r\n    void Write(string message);\r\n}\r\n```\r\n\r\nBecause output activity is synchronous and doesn't return any value\r\nit will inherit from the `SyncActivity` class. Also output activity requires a message to print out.\r\nThis can be experessed by declaring the property marked with `[Required]` attribute.\r\n\r\n```cs\r\npublic class WriteMessageActivity : SyncActivity\r\n{\r\n    private readonly IWriter _writer;\r\n\r\n    public WriteMessageActivity(IWriter writer)\r\n    {\r\n        _writer = writer;\r\n    }\r\n\r\n    [Required]\r\n    public string Message { get; set; }\r\n\r\n    protected override void ExecuteActivity() \r\n    {\r\n        _writer.Write(Message);\r\n    }\r\n}\r\n```\r\n\r\nEvery activity may fail or be cancelled. That's why we also need to define fault handler \r\nand cancellation handler activities:\r\n\r\n```cs\r\npublic class MyFaultHandler : SyncActivity, IFaultHandlerActivity\r\n{\r\n    public Exception Exception { get; set; }\r\n    \r\n    protected override void ExecuteActivity()\r\n    {\r\n        Console.WriteLine(Exception);\r\n    }\r\n}\r\n\r\npublic class MyCancellationHandler : SyncActivity\r\n{\r\n    protected override void ExecuteActivity()\r\n    {\r\n        Console.WriteLine(\"Cancelled\");\r\n    }\r\n}\r\n```\r\n\r\nBefore creating the flow itself we should provide the implementations of the `IReader` and `IWriter`\r\nservices:\r\n\r\n```cs\r\npublic class ConsoleReader : IReader\r\n{\r\n    public string Read() => Console.ReadLine();\r\n}\r\n\r\npublic class ConsoleWriter : IWriter\r\n{\r\n    public string Write(string message)\r\n    {\r\n        Console.WriteLine(message);\r\n    }\r\n}\r\n```\r\n\r\nNow we are ready to define the flow. All flows inherit from the `Flow` class. \r\nThis base class allows to build the flow structure, configure the dependency injection and run the flow.\r\n\r\n```cs\r\npublic class Flow1 : Flow\r\n{\r\n    public override string Name => \"Flow1. Uses condition node\";\r\n\r\n    protected override void Build(FlowBuilder builder)\r\n    {\r\n        // Create reading activity nodes.\r\n        var inputFirst = builder.Activity<ReadIntActivity>();\r\n        inputFirst.WithName(\"Read first number\");\r\n        \r\n        var inputSecond = builder.Activity<ReadIntActivity>();\r\n        inputSecond.WithName(\"Read second number\");\r\n\r\n        // Create bindings to the results.\r\n        var first = Result<int>.Of(inputFirst);\r\n        var second = Result<int>.Of(inputSecond);\r\n\r\n        // Create condition node.\r\n        var condition = builder.Condition();\r\n        condition.WithName(\"If first number > second number\");\r\n        \r\n        // Set condition to the expression.\r\n        condition.WithCondition(() => first.Get() > second.Get());\r\n\r\n        // Create true branch output activity.\r\n        var outputWhenTrue = builder.Activity<WriteMessageActivity>();\r\n        outputWhenTrue.WithName(\"Output: first > second\");\r\n        \r\n        // Bind the output message to the expression.\r\n        outputWhenTrue.Bind(x => x.Message)\r\n                      .To(() => $\"{first.Get()} > {second.Get()}\");\r\n\r\n        // Create false branch output activity.\r\n        var outputWhenFalse = builder.Activity<WriteMessageActivity>();\r\n        outputWhenFalse.WithName(\"Output: first <= second\");\r\n        \r\n        // Bind the output message to the expression.\r\n        outputWhenFalse.Bind(x => x.Message)\r\n                       .To(() => $\"{first.Get()} <= {second.Get()}\");\r\n\r\n        // Set initial node of the flow.\r\n        builder.WithInitialNode(inputFirst);\r\n        \r\n        // Set default fault and cancellation handlers.\r\n        builder.WithDefaultFaultHandler<MyFaultHandler>();\r\n        builder.WithDefaultCancellationHandler<MyCancellationHandler>();\r\n\r\n        //\r\n        // Connect nodes.\r\n        //\r\n\r\n        inputFirst.ConnectTo(inputSecond);\r\n        inputSecond.ConnectTo(condition);\r\n\r\n        condition.ConnectTrueTo(outputWhenTrue)\r\n                 .ConnectFalseTo(outputWhenFalse);\r\n    }\r\n\r\n    protected override void ConfigureServices(IServiceCollection services)\r\n    {\r\n        // Register services.\r\n        services.AddSingleton<IReader, ConsoleReader>();\r\n        services.AddSingleton<IWriter, ConsoleWriter>();\r\n    }\r\n}\r\n```\r\n\r\nThat's it. Now we can create the instance of the flow and run it:\r\n\r\n```cs\r\npublic static void Main(string[] args)\r\n{\r\n    var flow = new Flow1();\r\n    flow.Run();\r\n}\r\n```\r\n\r\n\r\n### Special thanks\r\n\r\n<img src=\"https://pbs.twimg.com/profile_images/674917637646716928/lni0by_I.png\" width=\"64px\" />\r\n\r\n[ReSharper](http://www.jetbrains.com/resharper/) - the most advanced productivity add-in for Visual Studio!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}